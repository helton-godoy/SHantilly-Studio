#include "ScriptGenerator.h"
#include <QMetaProperty>
#include <QDebug>
#include <QLayout>
#include <QTabWidget>

ScriptGenerator::ScriptGenerator()
{
}

QString ScriptGenerator::generate(QWidget *root)
{
    if (!root) return QString();

    QString script;
    script += "#!/bin/bash\n";
    script += "# Generated by Showbox Studio\n\n";
    script += "showbox << EOD\n";

    // Criar uma janela principal implícita para conter os widgets do Canvas
    // TODO: Permitir configurar título/tamanho da janela principal no Studio
    script += "add window \"Preview\" main_window width=800 height=600\n\n";

    // Assumindo que 'root' é o container onde os widgets foram soltos (ex: Canvas)
    const QObjectList &children = root->children();
    for (QObject *child : children) {
        if (QWidget *w = qobject_cast<QWidget*>(child)) {
            processWidget(w, script);
        }
    }

    script += "show\n"; // Garantir que a janela seja exibida
    script += "EOD\n";
    return script;
}

void ScriptGenerator::processWidget(QWidget *widget, QString &script)
{
    if (!widget) return;
    
    // Ignorar widgets internos ou não gerenciados
    if (widget->property("showbox_ignore").toBool()) return;

    QString type = getShowboxType(widget);
    if (type.isEmpty()) return; // Não sabemos exportar este tipo

    // Extrair Título/Texto (Argumento posicional 2)
    QString title = "";
    QVariant textProp = widget->property("text");
    QVariant titleProp = widget->property("title");
    
    if (textProp.isValid() && !textProp.toString().isEmpty()) title = textProp.toString();
    else if (titleProp.isValid() && !titleProp.toString().isEmpty()) title = titleProp.toString();
    
    // Escapar aspas no título
    title.replace("\"", "\\\"");
    title = "\"" + title + "\"";

    // Extrair Nome (Argumento posicional 3)
    QString name = widget->objectName();
    if (name.isEmpty()) name = "unnamed_" + QString::number((quintptr)widget);

    // Extrair Opções (Argumentos restantes)
    QString options = getPropertiesString(widget);
    
    // Formato: add type "title" name options...
    script += QString("add %1 %2 %3 %4\n").arg(type, title, name, options);

    // Recursão APENAS para containers conhecidos
    // Isso evita entrar em widgets complexos como ComboBox e listar seus componentes internos
    bool isContainer = (type == "window" || type == "groupbox" || type == "frame" || 
                        type == "tabwidget" || type == "page");

    if (isContainer) {
        // Caso Especial: QTabWidget
        if (QTabWidget *tab = qobject_cast<QTabWidget*>(widget)) {
            for (int i = 0; i < tab->count(); ++i) {
                processWidget(tab->widget(i), script);
            }
        } 
        // Caso Padrão: Containers com Layout ou Filhos Diretos
        else {
            QList<QWidget*> childWidgets;
            if (widget->layout()) {
                QLayout *layout = widget->layout();
                for (int i = 0; i < layout->count(); ++i) {
                    if (QWidget *w = layout->itemAt(i)->widget()) {
                        childWidgets.append(w);
                    }
                }
            } else {
                for (QObject *child : widget->children()) {
                    if (QWidget *w = qobject_cast<QWidget*>(child)) {
                        childWidgets.append(w);
                    }
                }
            }
            // Processar filhos coletados
            for (QWidget *child : childWidgets) {
                processWidget(child, script);
            }
        }
    }
    
    // Fechamento de contexto para containers
    if (type == "groupbox" || type == "frame" || type == "tabwidget" || type == "page") {
        script += "end\n";
    }
}

QString ScriptGenerator::getShowboxType(QWidget *widget)
{
    // Prioridade 1: Propriedade explícita definida pela Factory
    QVariant typeProp = widget->property("showbox_type");
    if (typeProp.isValid() && !typeProp.toString().isEmpty()) {
        return typeProp.toString();
    }

    // Fallback: Tentativa de inferência por nome de classe (Legado/Depuração)
    const QMetaObject *meta = widget->metaObject();
    QString cls = meta->className(); // ex: "QPushButton", "QLabel"
    
    // Mapeamento manual
    if (cls.contains("Button")) {
        if (cls.contains("Check")) return "checkbox";
        if (cls.contains("Radio")) return "radiobutton";
        return "button"; 
    }
    if (cls.contains("Label")) return "label";
    if (cls.contains("LineEdit")) return "textbox";
    if (cls.contains("TextEdit")) return "textedit";
    if (cls.contains("SpinBox")) return "spinbox";
    if (cls.contains("Slider")) return "slider";
    if (cls.contains("ComboBox")) return "combobox";
    if (cls.contains("ListWidget") || cls.contains("ListView")) return "listbox";
    if (cls.contains("ProgressBar")) return "progressbar";
    if (cls.contains("GroupBox")) return "groupbox";
    if (cls.contains("TabWidget")) return "tabwidget";
    if (cls.contains("Frame")) return "frame";
    if (cls.contains("Table")) return "table";
    if (cls.contains("Calendar")) return "calendar";
    if (cls.contains("Line")) return "separator";
    
    if (cls.contains("ChartWidget")) return "chart";

    return "";
}

QString ScriptGenerator::getPropertiesString(QWidget *widget)
{
    QStringList parts;
    
    // Nota: Name, Text e Title já são passados como argumentos posicionais
    // no comando 'add', então não precisamos repeti-los aqui,
    // A MENOS que o parser suporte redundância ou precise deles para 'set'.
    // O ParserMain lê options com WidgetParserUtils::findValue/hasFlag.
    
    // Geometria
    if (widget->width() > 0 && widget->width() != 100 && widget->width() != 640) 
        parts << QString("width=%1").arg(widget->width());
    if (widget->height() > 0 && widget->height() != 30 && widget->height() != 480) 
        parts << QString("height=%1").arg(widget->height());

    // Booleanos
    if (widget->property("checked").isValid() && widget->property("checked").toBool()) 
        parts << "checked"; // Flag style
    
    // ParserMain usa flags para algumas coisas: 'checked', 'readonly', 'password'
    
    if (widget->property("readOnly").isValid() && widget->property("readOnly").toBool())
        parts << "readonly";
        
    if (widget->property("echoMode").isValid() && widget->property("echoMode").toInt() == 2) // Password
        parts << "password";

    // Valores numéricos
    if (widget->property("value").isValid())
        parts << QString("value=%1").arg(widget->property("value").toInt());
        
    if (widget->property("minimum").isValid())
        parts << QString("minimum=%1").arg(widget->property("minimum").toInt());
        
    if (widget->property("maximum").isValid())
        parts << QString("maximum=%1").arg(widget->property("maximum").toInt());

    return parts.join(" ");
}
